import fetch from 'isomorphic-fetch';
import ReconnectingWebSocket from 'reconnecting-websocket';
import { equals, adjust } from 'ramda';
import { v4 } from 'uuid';

var name = "@nlxai/chat-core";
var version = "0.1.53";
var description = "NLX Chat SDK core";
var type = "module";
var main = "lib/index.cjs";
var module = "lib/index.esm.js";
var browser = "lib/index.umd.js";
var types = "lib/index.d.ts";
var exports = {
	".": {
		types: "./lib/index.d.ts",
		"import": "./lib/index.esm.js",
		require: "./lib/index.cjs"
	}
};
var scripts = {
	build: "rm -rf lib && rollup -c --configPlugin typescript",
	docs: "rm -rf docs/ && typedoc && concat-md --decrease-title-levels --dir-name-as-title docs/ > docs/index.md",
	"lint:check": "eslint src/ --ext .ts,.tsx,.js,.jsx --max-warnings 0",
	lint: "eslint src/ --ext .ts,.tsx,.js,.jsx --fix",
	prepublish: "npm run build",
	"preview-docs": "npm run docs && comrak --unsafe --gfm -o docs/index.html docs/index.md && open docs/index.html",
	"publish-docs": "npm run docs && mv docs/index.md ../website/src/content/05-02-headless-api-reference.md",
	test: "typedoc --emit none",
	tsc: "tsc"
};
var author = "Peter Szerzo <peter@nlx.ai>";
var license = "MIT";
var devDependencies = {
	"@types/isomorphic-fetch": "^0.0.36",
	"@types/node": "^11.15.11",
	"@types/ramda": "0.29.1",
	"@types/uuid": "^9.0.7",
	"concat-md": "^0.5.1",
	"eslint-config-nlx": "*",
	prettier: "^3.1.0",
	"rollup-config-nlx": "*",
	typedoc: "^0.25.13",
	"typedoc-plugin-markdown": "^3.17.1",
	typescript: "^5.5.4"
};
var dependencies = {
	"isomorphic-fetch": "^3.0.0",
	ramda: "^0.29.1",
	"reconnecting-websocket": "^4.4.0",
	uuid: "^9.0.1"
};
var publishConfig = {
	access: "public"
};
var gitHead = "82bdb85e97d76034a236332b1a58c6c37e729c54";
var packageJson = {
	name: name,
	version: version,
	description: description,
	type: type,
	main: main,
	module: module,
	browser: browser,
	types: types,
	exports: exports,
	scripts: scripts,
	author: author,
	license: license,
	devDependencies: devDependencies,
	dependencies: dependencies,
	publishConfig: publishConfig,
	gitHead: gitHead
};

// use a custom Console to indicate we really want to log to the console and it's not incidental. `console.log` causes an eslint error
const Console = console;
const welcomeIntent = "NLX.Welcome";
const defaultFailureMessage = "We encountered an issue. Please try again soon.";
const normalizeSlots = (slotsRecordOrArray) => {
    if (Array.isArray(slotsRecordOrArray)) {
        return slotsRecordOrArray;
    }
    return Object.entries(slotsRecordOrArray).map(([key, value]) => ({
        slotId: key,
        value,
    }));
};
const fromInternal = (internalState) => internalState.responses;
const safeJsonParse = (val) => {
    try {
        const json = JSON.parse(val);
        return json;
    }
    catch (_err) {
        return null;
    }
};
/**
 * Helper method to decide when a new {@link Config} requires creating a new {@link ConversationHandler} or whether the old `Config`'s
 * `ConversationHandler` can be used.
 *
 * The order of configs doesn't matter.
 * @param config1 -
 * @param config2 -
 * @returns true if `createConversation` should be called again
 */
const shouldReinitialize = (config1, config2) => {
    return !equals(config1, config2);
};
/**
 * Call this to create a conversation handler.
 * @param config -
 * @returns The {@link ConversationHandler} is a bundle of functions to interact with the conversation.
 */
function createConversation(config) {
    let socket;
    // Check if the bot URL has a language code appended to it
    if (/[-|_][a-z]{2,}[-|_][A-Z]{2,}$/.test(config.botUrl)) {
        Console.warn("Since v1.0.0, the language code is no longer added at the end of the bot URL. Please remove the modifier (e.g. '-en-US') from the URL, and specify it in the `languageCode` parameter instead.");
    }
    const initialConversationId = config.conversationId ?? v4();
    let state = {
        responses: config.responses ?? [],
        userId: config.userId,
        conversationId: initialConversationId,
    };
    const setState = (change, 
    // Optionally send the response that causes the current state change, to be sent to subscribers
    newResponse) => {
        state = {
            ...state,
            ...change,
        };
        subscribers.forEach((subscriber) => {
            subscriber(fromInternal(state), newResponse);
        });
    };
    const failureHandler = () => {
        const newResponse = {
            type: "failure",
            receivedAt: new Date().getTime(),
            payload: {
                text: config.failureMessage ?? defaultFailureMessage,
            },
        };
        setState({
            responses: [...state.responses, newResponse],
        }, newResponse);
    };
    const messageResponseHandler = (response) => {
        if (response?.messages.length > 0) {
            const newResponse = {
                type: "bot",
                receivedAt: new Date().getTime(),
                payload: {
                    ...response,
                    messages: response.messages.map((message) => ({
                        nodeId: message.nodeId,
                        messageId: message.messageId,
                        text: message.text,
                        choices: message.choices ?? [],
                    })),
                },
            };
            setState({
                responses: [...state.responses, newResponse],
            }, newResponse);
            if (response.metadata.hasPendingDataRequest) {
                appendStructuredUserResponse({ poll: true });
                setTimeout(() => {
                    void sendToBot({
                        request: {
                            structured: {
                                poll: true,
                            },
                        },
                    });
                }, 1500);
            }
        }
        else {
            Console.warn("Invalid message structure, expected object with field 'messages'.");
            failureHandler();
        }
    };
    let botRequestOverride;
    let socketMessageQueue = [];
    let socketMessageQueueCheckInterval = null;
    const sendToBot = async (body) => {
        if (botRequestOverride != null) {
            botRequestOverride(body, (payload) => {
                const newResponse = {
                    type: "bot",
                    receivedAt: new Date().getTime(),
                    payload,
                };
                setState({
                    responses: [...state.responses, newResponse],
                }, newResponse);
            });
            return;
        }
        const bodyWithContext = {
            userId: state.userId,
            conversationId: state.conversationId,
            ...body,
            languageCode: config.languageCode,
            channelType: config.experimental?.channelType,
            environment: config.environment,
        };
        if (isUsingWebSockets()) {
            if (socket?.readyState === 1) {
                socket.send(JSON.stringify(bodyWithContext));
            }
            else {
                socketMessageQueue = [...socketMessageQueue, bodyWithContext];
            }
        }
        else {
            await fetch(`${config.botUrl}${config.experimental?.completeBotUrl === true
                ? ""
                : `-${config.languageCode}`}`, {
                method: "POST",
                headers: {
                    ...(config.headers ?? {}),
                    Accept: "application/json",
                    "Content-Type": "application/json",
                    "nlx-sdk-version": packageJson.version,
                },
                body: JSON.stringify(bodyWithContext),
            })
                .then(async (res) => {
                return await res.json();
            })
                .then(messageResponseHandler)
                .catch((err) => {
                Console.warn(err);
                failureHandler();
            });
        }
    };
    const isUsingWebSockets = () => {
        return config.botUrl.indexOf("wss://") === 0;
    };
    let subscribers = [];
    const setupWebsocket = () => {
        const url = new URL(config.botUrl);
        if (config.experimental?.completeBotUrl !== true) {
            url.searchParams.set("languageCode", config.languageCode);
            url.searchParams.set("channelKey", `${url.searchParams.get("channelKey") ?? ""}-${config.languageCode}`);
        }
        url.searchParams.set("conversationId", state.conversationId);
        socket = new ReconnectingWebSocket(url.href);
        socketMessageQueueCheckInterval = setInterval(() => {
        }, 500);
        socket.onmessage = function (e) {
            if (typeof e?.data === "string") {
                messageResponseHandler(safeJsonParse(e.data));
            }
        };
    };
    const teardownWebsocket = () => {
        if (socketMessageQueueCheckInterval != null) {
            clearInterval(socketMessageQueueCheckInterval);
        }
        if (socket != null) {
            socket.onmessage = null;
            socket.close();
            socket = undefined;
        }
    };
    if (isUsingWebSockets()) {
        setupWebsocket();
    }
    const appendStructuredUserResponse = (structured, context) => {
        const newResponse = {
            type: "user",
            receivedAt: new Date().getTime(),
            payload: {
                type: "structured",
                ...structured,
                context,
            },
        };
        setState({
            responses: [...state.responses, newResponse],
        }, newResponse);
    };
    const sendIntent = (intentId, context) => {
        appendStructuredUserResponse({ intentId }, context);
        void sendToBot({
            context,
            request: {
                structured: {
                    intentId,
                },
            },
        });
    };
    const sendText = (text, context) => {
        const newResponse = {
            type: "user",
            receivedAt: new Date().getTime(),
            payload: {
                type: "text",
                text,
                context,
            },
        };
        setState({
            responses: [...state.responses, newResponse],
        }, newResponse);
        void sendToBot({
            context,
            request: {
                unstructured: {
                    text,
                },
            },
        });
    };
    const unsubscribe = (subscriber) => {
        subscribers = subscribers.filter((fn) => fn !== subscriber);
    };
    const subscribe = (subscriber) => {
        subscribers = [...subscribers, subscriber];
        subscriber(fromInternal(state));
        return () => {
            unsubscribe(subscriber);
        };
    };
    return {
        sendText,
        sendStructured: (structured, context) => {
            appendStructuredUserResponse(structured, context);
            void sendToBot({
                context,
                request: {
                    structured: {
                        ...structured,
                        slots: normalizeSlots(structured.slots ?? []),
                    },
                },
            });
        },
        sendSlots: (slots, context) => {
            appendStructuredUserResponse({ slots }, context);
            void sendToBot({
                context,
                request: {
                    structured: {
                        slots: normalizeSlots(slots),
                    },
                },
            });
        },
        sendIntent,
        sendWelcomeIntent: (context) => {
            sendIntent(welcomeIntent, context);
        },
        sendChoice: (choiceId, context, metadata) => {
            let newResponses = [...state.responses];
            const choiceResponse = {
                type: "user",
                receivedAt: new Date().getTime(),
                payload: {
                    type: "choice",
                    choiceId,
                },
            };
            const responseIndex = metadata?.responseIndex ?? -1;
            const messageIndex = metadata?.messageIndex ?? -1;
            if (responseIndex > -1 && messageIndex > -1) {
                newResponses = adjust(responseIndex, (response) => response.type === "bot"
                    ? {
                        ...response,
                        payload: {
                            ...response.payload,
                            messages: adjust(messageIndex, (message) => ({ ...message, selectedChoiceId: choiceId }), response.payload.messages),
                        },
                    }
                    : response, newResponses);
            }
            newResponses = [...newResponses, choiceResponse];
            setState({
                responses: newResponses,
            }, choiceResponse);
            void sendToBot({
                context,
                request: {
                    structured: {
                        nodeId: metadata?.nodeId,
                        intentId: metadata?.intentId,
                        choiceId,
                    },
                },
            });
        },
        currentConversationId: () => {
            return state.conversationId;
        },
        subscribe,
        unsubscribe,
        unsubscribeAll: () => {
            subscribers = [];
        },
        reset: (options) => {
            setState({
                conversationId: v4(),
                responses: options?.clearResponses === true ? [] : state.responses,
            });
            if (isUsingWebSockets()) {
                teardownWebsocket();
                setupWebsocket();
            }
        },
        destroy: () => {
            subscribers = [];
            if (isUsingWebSockets()) {
                teardownWebsocket();
            }
        },
        setBotRequestOverride: (val) => {
            botRequestOverride = val;
        },
    };
}
/**
 * Get current expiration timestamp from the current list of reponses
 * @param responses - the current list of user and bot responses (first argument in the subscribe callback)
 * @returns an expiration timestamp in Unix Epoch (`new Date().getTime()`), or `null` if this is not known (typically occurs if the bot has not responded yet)
 */
const getCurrentExpirationTimestamp = (responses) => {
    let expirationTimestamp = null;
    responses.forEach((response) => {
        if (response.type === "bot" &&
            response.payload.expirationTimestamp != null) {
            expirationTimestamp = response.payload.expirationTimestamp;
        }
    });
    return expirationTimestamp;
};
/**
 * This package is intentionally designed with a subscription-based API as opposed to a promise-based one where each message corresponds to a single bot response, available asynchronously.
 *
 * If you need a promise-based wrapper, you can use the `promisify` helper available in the package:
 * @example
 * ```typescript
 * import { createConversation, promisify } from "@nlxai/chat-core";
 *
 * const convo = createConversation(config);
 *
 * const sendTextWrapped = promisify(convo.sendText, convo);
 *
 * sendTextWrapped("Hello").then((response) => {
 *   console.log(response);
 * });
 * ```
 * @typeParam T - the type of the function's params, e.g. for `sendText` it's `text: string, context?: Context`
 * @param fn - the function to wrap (e.g. `convo.sendText`, `convo.sendChoice`, etc.)
 * @param convo - the `ConversationHandler` (from {@link createConversation})
 * @param timeout - the timeout in milliseconds
 * @returns A promise-wrapped version of the function. The function, when called, returns a promise that resolves to the Conversation's next response.
 */
function promisify(fn, convo, timeout = 10000) {
    return async (payload) => {
        return await new Promise((resolve, reject) => {
            const timeoutId = setTimeout(() => {
                reject(new Error("The request timed out."));
                convo.unsubscribe(subscription);
            }, timeout);
            const subscription = (_responses, newResponse) => {
                if (newResponse?.type === "bot" || newResponse?.type === "failure") {
                    clearTimeout(timeoutId);
                    convo.unsubscribe(subscription);
                    resolve(newResponse);
                }
            };
            convo.subscribe(subscription);
            fn(payload);
        });
    };
}

export { createConversation, getCurrentExpirationTimestamp, promisify, shouldReinitialize };
