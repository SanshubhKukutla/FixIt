{"ast":null,"code":"import fetch from 'isomorphic-fetch';\nimport ReconnectingWebSocket from 'reconnecting-websocket';\nimport { equals, adjust } from 'ramda';\nimport { v4 } from 'uuid';\nvar name = \"@nlxai/chat-core\";\nvar version = \"0.1.53\";\nvar description = \"NLX Chat SDK core\";\nvar type = \"module\";\nvar main = \"lib/index.cjs\";\nvar module = \"lib/index.esm.js\";\nvar browser = \"lib/index.umd.js\";\nvar types = \"lib/index.d.ts\";\nvar exports = {\n  \".\": {\n    types: \"./lib/index.d.ts\",\n    \"import\": \"./lib/index.esm.js\",\n    require: \"./lib/index.cjs\"\n  }\n};\nvar scripts = {\n  build: \"rm -rf lib && rollup -c --configPlugin typescript\",\n  docs: \"rm -rf docs/ && typedoc && concat-md --decrease-title-levels --dir-name-as-title docs/ > docs/index.md\",\n  \"lint:check\": \"eslint src/ --ext .ts,.tsx,.js,.jsx --max-warnings 0\",\n  lint: \"eslint src/ --ext .ts,.tsx,.js,.jsx --fix\",\n  prepublish: \"npm run build\",\n  \"preview-docs\": \"npm run docs && comrak --unsafe --gfm -o docs/index.html docs/index.md && open docs/index.html\",\n  \"publish-docs\": \"npm run docs && mv docs/index.md ../website/src/content/05-02-headless-api-reference.md\",\n  test: \"typedoc --emit none\",\n  tsc: \"tsc\"\n};\nvar author = \"Peter Szerzo <peter@nlx.ai>\";\nvar license = \"MIT\";\nvar devDependencies = {\n  \"@types/isomorphic-fetch\": \"^0.0.36\",\n  \"@types/node\": \"^11.15.11\",\n  \"@types/ramda\": \"0.29.1\",\n  \"@types/uuid\": \"^9.0.7\",\n  \"concat-md\": \"^0.5.1\",\n  \"eslint-config-nlx\": \"*\",\n  prettier: \"^3.1.0\",\n  \"rollup-config-nlx\": \"*\",\n  typedoc: \"^0.25.13\",\n  \"typedoc-plugin-markdown\": \"^3.17.1\",\n  typescript: \"^5.5.4\"\n};\nvar dependencies = {\n  \"isomorphic-fetch\": \"^3.0.0\",\n  ramda: \"^0.29.1\",\n  \"reconnecting-websocket\": \"^4.4.0\",\n  uuid: \"^9.0.1\"\n};\nvar publishConfig = {\n  access: \"public\"\n};\nvar gitHead = \"82bdb85e97d76034a236332b1a58c6c37e729c54\";\nvar packageJson = {\n  name: name,\n  version: version,\n  description: description,\n  type: type,\n  main: main,\n  module: module,\n  browser: browser,\n  types: types,\n  exports: exports,\n  scripts: scripts,\n  author: author,\n  license: license,\n  devDependencies: devDependencies,\n  dependencies: dependencies,\n  publishConfig: publishConfig,\n  gitHead: gitHead\n};\n\n// use a custom Console to indicate we really want to log to the console and it's not incidental. `console.log` causes an eslint error\nconst Console = console;\nconst welcomeIntent = \"NLX.Welcome\";\nconst defaultFailureMessage = \"We encountered an issue. Please try again soon.\";\nconst normalizeSlots = slotsRecordOrArray => {\n  if (Array.isArray(slotsRecordOrArray)) {\n    return slotsRecordOrArray;\n  }\n  return Object.entries(slotsRecordOrArray).map(([key, value]) => ({\n    slotId: key,\n    value\n  }));\n};\nconst fromInternal = internalState => internalState.responses;\nconst safeJsonParse = val => {\n  try {\n    const json = JSON.parse(val);\n    return json;\n  } catch (_err) {\n    return null;\n  }\n};\n/**\n * Helper method to decide when a new {@link Config} requires creating a new {@link ConversationHandler} or whether the old `Config`'s\n * `ConversationHandler` can be used.\n *\n * The order of configs doesn't matter.\n * @param config1 -\n * @param config2 -\n * @returns true if `createConversation` should be called again\n */\nconst shouldReinitialize = (config1, config2) => {\n  return !equals(config1, config2);\n};\n/**\n * Call this to create a conversation handler.\n * @param config -\n * @returns The {@link ConversationHandler} is a bundle of functions to interact with the conversation.\n */\nfunction createConversation(config) {\n  let socket;\n  // Check if the bot URL has a language code appended to it\n  if (/[-|_][a-z]{2,}[-|_][A-Z]{2,}$/.test(config.botUrl)) {\n    Console.warn(\"Since v1.0.0, the language code is no longer added at the end of the bot URL. Please remove the modifier (e.g. '-en-US') from the URL, and specify it in the `languageCode` parameter instead.\");\n  }\n  const initialConversationId = config.conversationId ?? v4();\n  let state = {\n    responses: config.responses ?? [],\n    userId: config.userId,\n    conversationId: initialConversationId\n  };\n  const setState = (change,\n  // Optionally send the response that causes the current state change, to be sent to subscribers\n  newResponse) => {\n    state = {\n      ...state,\n      ...change\n    };\n    subscribers.forEach(subscriber => {\n      subscriber(fromInternal(state), newResponse);\n    });\n  };\n  const failureHandler = () => {\n    const newResponse = {\n      type: \"failure\",\n      receivedAt: new Date().getTime(),\n      payload: {\n        text: config.failureMessage ?? defaultFailureMessage\n      }\n    };\n    setState({\n      responses: [...state.responses, newResponse]\n    }, newResponse);\n  };\n  const messageResponseHandler = response => {\n    if (response?.messages.length > 0) {\n      const newResponse = {\n        type: \"bot\",\n        receivedAt: new Date().getTime(),\n        payload: {\n          ...response,\n          messages: response.messages.map(message => ({\n            nodeId: message.nodeId,\n            messageId: message.messageId,\n            text: message.text,\n            choices: message.choices ?? []\n          }))\n        }\n      };\n      setState({\n        responses: [...state.responses, newResponse]\n      }, newResponse);\n      if (response.metadata.hasPendingDataRequest) {\n        appendStructuredUserResponse({\n          poll: true\n        });\n        setTimeout(() => {\n          void sendToBot({\n            request: {\n              structured: {\n                poll: true\n              }\n            }\n          });\n        }, 1500);\n      }\n    } else {\n      Console.warn(\"Invalid message structure, expected object with field 'messages'.\");\n      failureHandler();\n    }\n  };\n  let botRequestOverride;\n  let socketMessageQueue = [];\n  let socketMessageQueueCheckInterval = null;\n  const sendToBot = async body => {\n    if (botRequestOverride != null) {\n      botRequestOverride(body, payload => {\n        const newResponse = {\n          type: \"bot\",\n          receivedAt: new Date().getTime(),\n          payload\n        };\n        setState({\n          responses: [...state.responses, newResponse]\n        }, newResponse);\n      });\n      return;\n    }\n    const bodyWithContext = {\n      userId: state.userId,\n      conversationId: state.conversationId,\n      ...body,\n      languageCode: config.languageCode,\n      channelType: config.experimental?.channelType,\n      environment: config.environment\n    };\n    if (isUsingWebSockets()) {\n      if (socket?.readyState === 1) {\n        socket.send(JSON.stringify(bodyWithContext));\n      } else {\n        socketMessageQueue = [...socketMessageQueue, bodyWithContext];\n      }\n    } else {\n      await fetch(`${config.botUrl}${config.experimental?.completeBotUrl === true ? \"\" : `-${config.languageCode}`}`, {\n        method: \"POST\",\n        headers: {\n          ...(config.headers ?? {}),\n          Accept: \"application/json\",\n          \"Content-Type\": \"application/json\",\n          \"nlx-sdk-version\": packageJson.version\n        },\n        body: JSON.stringify(bodyWithContext)\n      }).then(async res => {\n        return await res.json();\n      }).then(messageResponseHandler).catch(err => {\n        Console.warn(err);\n        failureHandler();\n      });\n    }\n  };\n  const isUsingWebSockets = () => {\n    return config.botUrl.indexOf(\"wss://\") === 0;\n  };\n  let subscribers = [];\n  const setupWebsocket = () => {\n    const url = new URL(config.botUrl);\n    if (config.experimental?.completeBotUrl !== true) {\n      url.searchParams.set(\"languageCode\", config.languageCode);\n      url.searchParams.set(\"channelKey\", `${url.searchParams.get(\"channelKey\") ?? \"\"}-${config.languageCode}`);\n    }\n    url.searchParams.set(\"conversationId\", state.conversationId);\n    socket = new ReconnectingWebSocket(url.href);\n    socketMessageQueueCheckInterval = setInterval(() => {}, 500);\n    socket.onmessage = function (e) {\n      if (typeof e?.data === \"string\") {\n        messageResponseHandler(safeJsonParse(e.data));\n      }\n    };\n  };\n  const teardownWebsocket = () => {\n    if (socketMessageQueueCheckInterval != null) {\n      clearInterval(socketMessageQueueCheckInterval);\n    }\n    if (socket != null) {\n      socket.onmessage = null;\n      socket.close();\n      socket = undefined;\n    }\n  };\n  if (isUsingWebSockets()) {\n    setupWebsocket();\n  }\n  const appendStructuredUserResponse = (structured, context) => {\n    const newResponse = {\n      type: \"user\",\n      receivedAt: new Date().getTime(),\n      payload: {\n        type: \"structured\",\n        ...structured,\n        context\n      }\n    };\n    setState({\n      responses: [...state.responses, newResponse]\n    }, newResponse);\n  };\n  const sendIntent = (intentId, context) => {\n    appendStructuredUserResponse({\n      intentId\n    }, context);\n    void sendToBot({\n      context,\n      request: {\n        structured: {\n          intentId\n        }\n      }\n    });\n  };\n  const sendText = (text, context) => {\n    const newResponse = {\n      type: \"user\",\n      receivedAt: new Date().getTime(),\n      payload: {\n        type: \"text\",\n        text,\n        context\n      }\n    };\n    setState({\n      responses: [...state.responses, newResponse]\n    }, newResponse);\n    void sendToBot({\n      context,\n      request: {\n        unstructured: {\n          text\n        }\n      }\n    });\n  };\n  const unsubscribe = subscriber => {\n    subscribers = subscribers.filter(fn => fn !== subscriber);\n  };\n  const subscribe = subscriber => {\n    subscribers = [...subscribers, subscriber];\n    subscriber(fromInternal(state));\n    return () => {\n      unsubscribe(subscriber);\n    };\n  };\n  return {\n    sendText,\n    sendStructured: (structured, context) => {\n      appendStructuredUserResponse(structured, context);\n      void sendToBot({\n        context,\n        request: {\n          structured: {\n            ...structured,\n            slots: normalizeSlots(structured.slots ?? [])\n          }\n        }\n      });\n    },\n    sendSlots: (slots, context) => {\n      appendStructuredUserResponse({\n        slots\n      }, context);\n      void sendToBot({\n        context,\n        request: {\n          structured: {\n            slots: normalizeSlots(slots)\n          }\n        }\n      });\n    },\n    sendIntent,\n    sendWelcomeIntent: context => {\n      sendIntent(welcomeIntent, context);\n    },\n    sendChoice: (choiceId, context, metadata) => {\n      let newResponses = [...state.responses];\n      const choiceResponse = {\n        type: \"user\",\n        receivedAt: new Date().getTime(),\n        payload: {\n          type: \"choice\",\n          choiceId\n        }\n      };\n      const responseIndex = metadata?.responseIndex ?? -1;\n      const messageIndex = metadata?.messageIndex ?? -1;\n      if (responseIndex > -1 && messageIndex > -1) {\n        newResponses = adjust(responseIndex, response => response.type === \"bot\" ? {\n          ...response,\n          payload: {\n            ...response.payload,\n            messages: adjust(messageIndex, message => ({\n              ...message,\n              selectedChoiceId: choiceId\n            }), response.payload.messages)\n          }\n        } : response, newResponses);\n      }\n      newResponses = [...newResponses, choiceResponse];\n      setState({\n        responses: newResponses\n      }, choiceResponse);\n      void sendToBot({\n        context,\n        request: {\n          structured: {\n            nodeId: metadata?.nodeId,\n            intentId: metadata?.intentId,\n            choiceId\n          }\n        }\n      });\n    },\n    currentConversationId: () => {\n      return state.conversationId;\n    },\n    subscribe,\n    unsubscribe,\n    unsubscribeAll: () => {\n      subscribers = [];\n    },\n    reset: options => {\n      setState({\n        conversationId: v4(),\n        responses: options?.clearResponses === true ? [] : state.responses\n      });\n      if (isUsingWebSockets()) {\n        teardownWebsocket();\n        setupWebsocket();\n      }\n    },\n    destroy: () => {\n      subscribers = [];\n      if (isUsingWebSockets()) {\n        teardownWebsocket();\n      }\n    },\n    setBotRequestOverride: val => {\n      botRequestOverride = val;\n    }\n  };\n}\n/**\n * Get current expiration timestamp from the current list of reponses\n * @param responses - the current list of user and bot responses (first argument in the subscribe callback)\n * @returns an expiration timestamp in Unix Epoch (`new Date().getTime()`), or `null` if this is not known (typically occurs if the bot has not responded yet)\n */\nconst getCurrentExpirationTimestamp = responses => {\n  let expirationTimestamp = null;\n  responses.forEach(response => {\n    if (response.type === \"bot\" && response.payload.expirationTimestamp != null) {\n      expirationTimestamp = response.payload.expirationTimestamp;\n    }\n  });\n  return expirationTimestamp;\n};\n/**\n * This package is intentionally designed with a subscription-based API as opposed to a promise-based one where each message corresponds to a single bot response, available asynchronously.\n *\n * If you need a promise-based wrapper, you can use the `promisify` helper available in the package:\n * @example\n * ```typescript\n * import { createConversation, promisify } from \"@nlxai/chat-core\";\n *\n * const convo = createConversation(config);\n *\n * const sendTextWrapped = promisify(convo.sendText, convo);\n *\n * sendTextWrapped(\"Hello\").then((response) => {\n *   console.log(response);\n * });\n * ```\n * @typeParam T - the type of the function's params, e.g. for `sendText` it's `text: string, context?: Context`\n * @param fn - the function to wrap (e.g. `convo.sendText`, `convo.sendChoice`, etc.)\n * @param convo - the `ConversationHandler` (from {@link createConversation})\n * @param timeout - the timeout in milliseconds\n * @returns A promise-wrapped version of the function. The function, when called, returns a promise that resolves to the Conversation's next response.\n */\nfunction promisify(fn, convo, timeout = 10000) {\n  return async payload => {\n    return await new Promise((resolve, reject) => {\n      const timeoutId = setTimeout(() => {\n        reject(new Error(\"The request timed out.\"));\n        convo.unsubscribe(subscription);\n      }, timeout);\n      const subscription = (_responses, newResponse) => {\n        if (newResponse?.type === \"bot\" || newResponse?.type === \"failure\") {\n          clearTimeout(timeoutId);\n          convo.unsubscribe(subscription);\n          resolve(newResponse);\n        }\n      };\n      convo.subscribe(subscription);\n      fn(payload);\n    });\n  };\n}\nexport { createConversation, getCurrentExpirationTimestamp, promisify, shouldReinitialize };","map":{"version":3,"names":["fetch","ReconnectingWebSocket","equals","adjust","v4","name","version","description","type","main","module","browser","types","exports","require","scripts","build","docs","lint","prepublish","test","tsc","author","license","devDependencies","prettier","typedoc","typescript","dependencies","ramda","uuid","publishConfig","access","gitHead","packageJson","Console","console","welcomeIntent","defaultFailureMessage","normalizeSlots","slotsRecordOrArray","Array","isArray","Object","entries","map","key","value","slotId","fromInternal","internalState","responses","safeJsonParse","val","json","JSON","parse","_err","shouldReinitialize","config1","config2","createConversation","config","socket","botUrl","warn","initialConversationId","conversationId","state","userId","setState","change","newResponse","subscribers","forEach","subscriber","failureHandler","receivedAt","Date","getTime","payload","text","failureMessage","messageResponseHandler","response","messages","length","message","nodeId","messageId","choices","metadata","hasPendingDataRequest","appendStructuredUserResponse","poll","setTimeout","sendToBot","request","structured","botRequestOverride","socketMessageQueue","socketMessageQueueCheckInterval","body","bodyWithContext","languageCode","channelType","experimental","environment","isUsingWebSockets","readyState","send","stringify","completeBotUrl","method","headers","Accept","then","res","catch","err","indexOf","setupWebsocket","url","URL","searchParams","set","get","href","setInterval","onmessage","e","data","teardownWebsocket","clearInterval","close","undefined","context","sendIntent","intentId","sendText","unstructured","unsubscribe","filter","fn","subscribe","sendStructured","slots","sendSlots","sendWelcomeIntent","sendChoice","choiceId","newResponses","choiceResponse","responseIndex","messageIndex","selectedChoiceId","currentConversationId","unsubscribeAll","reset","options","clearResponses","destroy","setBotRequestOverride","getCurrentExpirationTimestamp","expirationTimestamp","promisify","convo","timeout","Promise","resolve","reject","timeoutId","Error","subscription","_responses","clearTimeout"],"sources":["/Users/ananyapattamatta/Desktop/FixIt/FixIt/frontend/node_modules/@nlxai/chat-core/lib/index.esm.js"],"sourcesContent":["import fetch from 'isomorphic-fetch';\nimport ReconnectingWebSocket from 'reconnecting-websocket';\nimport { equals, adjust } from 'ramda';\nimport { v4 } from 'uuid';\n\nvar name = \"@nlxai/chat-core\";\nvar version = \"0.1.53\";\nvar description = \"NLX Chat SDK core\";\nvar type = \"module\";\nvar main = \"lib/index.cjs\";\nvar module = \"lib/index.esm.js\";\nvar browser = \"lib/index.umd.js\";\nvar types = \"lib/index.d.ts\";\nvar exports = {\n\t\".\": {\n\t\ttypes: \"./lib/index.d.ts\",\n\t\t\"import\": \"./lib/index.esm.js\",\n\t\trequire: \"./lib/index.cjs\"\n\t}\n};\nvar scripts = {\n\tbuild: \"rm -rf lib && rollup -c --configPlugin typescript\",\n\tdocs: \"rm -rf docs/ && typedoc && concat-md --decrease-title-levels --dir-name-as-title docs/ > docs/index.md\",\n\t\"lint:check\": \"eslint src/ --ext .ts,.tsx,.js,.jsx --max-warnings 0\",\n\tlint: \"eslint src/ --ext .ts,.tsx,.js,.jsx --fix\",\n\tprepublish: \"npm run build\",\n\t\"preview-docs\": \"npm run docs && comrak --unsafe --gfm -o docs/index.html docs/index.md && open docs/index.html\",\n\t\"publish-docs\": \"npm run docs && mv docs/index.md ../website/src/content/05-02-headless-api-reference.md\",\n\ttest: \"typedoc --emit none\",\n\ttsc: \"tsc\"\n};\nvar author = \"Peter Szerzo <peter@nlx.ai>\";\nvar license = \"MIT\";\nvar devDependencies = {\n\t\"@types/isomorphic-fetch\": \"^0.0.36\",\n\t\"@types/node\": \"^11.15.11\",\n\t\"@types/ramda\": \"0.29.1\",\n\t\"@types/uuid\": \"^9.0.7\",\n\t\"concat-md\": \"^0.5.1\",\n\t\"eslint-config-nlx\": \"*\",\n\tprettier: \"^3.1.0\",\n\t\"rollup-config-nlx\": \"*\",\n\ttypedoc: \"^0.25.13\",\n\t\"typedoc-plugin-markdown\": \"^3.17.1\",\n\ttypescript: \"^5.5.4\"\n};\nvar dependencies = {\n\t\"isomorphic-fetch\": \"^3.0.0\",\n\tramda: \"^0.29.1\",\n\t\"reconnecting-websocket\": \"^4.4.0\",\n\tuuid: \"^9.0.1\"\n};\nvar publishConfig = {\n\taccess: \"public\"\n};\nvar gitHead = \"82bdb85e97d76034a236332b1a58c6c37e729c54\";\nvar packageJson = {\n\tname: name,\n\tversion: version,\n\tdescription: description,\n\ttype: type,\n\tmain: main,\n\tmodule: module,\n\tbrowser: browser,\n\ttypes: types,\n\texports: exports,\n\tscripts: scripts,\n\tauthor: author,\n\tlicense: license,\n\tdevDependencies: devDependencies,\n\tdependencies: dependencies,\n\tpublishConfig: publishConfig,\n\tgitHead: gitHead\n};\n\n// use a custom Console to indicate we really want to log to the console and it's not incidental. `console.log` causes an eslint error\nconst Console = console;\nconst welcomeIntent = \"NLX.Welcome\";\nconst defaultFailureMessage = \"We encountered an issue. Please try again soon.\";\nconst normalizeSlots = (slotsRecordOrArray) => {\n    if (Array.isArray(slotsRecordOrArray)) {\n        return slotsRecordOrArray;\n    }\n    return Object.entries(slotsRecordOrArray).map(([key, value]) => ({\n        slotId: key,\n        value,\n    }));\n};\nconst fromInternal = (internalState) => internalState.responses;\nconst safeJsonParse = (val) => {\n    try {\n        const json = JSON.parse(val);\n        return json;\n    }\n    catch (_err) {\n        return null;\n    }\n};\n/**\n * Helper method to decide when a new {@link Config} requires creating a new {@link ConversationHandler} or whether the old `Config`'s\n * `ConversationHandler` can be used.\n *\n * The order of configs doesn't matter.\n * @param config1 -\n * @param config2 -\n * @returns true if `createConversation` should be called again\n */\nconst shouldReinitialize = (config1, config2) => {\n    return !equals(config1, config2);\n};\n/**\n * Call this to create a conversation handler.\n * @param config -\n * @returns The {@link ConversationHandler} is a bundle of functions to interact with the conversation.\n */\nfunction createConversation(config) {\n    let socket;\n    // Check if the bot URL has a language code appended to it\n    if (/[-|_][a-z]{2,}[-|_][A-Z]{2,}$/.test(config.botUrl)) {\n        Console.warn(\"Since v1.0.0, the language code is no longer added at the end of the bot URL. Please remove the modifier (e.g. '-en-US') from the URL, and specify it in the `languageCode` parameter instead.\");\n    }\n    const initialConversationId = config.conversationId ?? v4();\n    let state = {\n        responses: config.responses ?? [],\n        userId: config.userId,\n        conversationId: initialConversationId,\n    };\n    const setState = (change, \n    // Optionally send the response that causes the current state change, to be sent to subscribers\n    newResponse) => {\n        state = {\n            ...state,\n            ...change,\n        };\n        subscribers.forEach((subscriber) => {\n            subscriber(fromInternal(state), newResponse);\n        });\n    };\n    const failureHandler = () => {\n        const newResponse = {\n            type: \"failure\",\n            receivedAt: new Date().getTime(),\n            payload: {\n                text: config.failureMessage ?? defaultFailureMessage,\n            },\n        };\n        setState({\n            responses: [...state.responses, newResponse],\n        }, newResponse);\n    };\n    const messageResponseHandler = (response) => {\n        if (response?.messages.length > 0) {\n            const newResponse = {\n                type: \"bot\",\n                receivedAt: new Date().getTime(),\n                payload: {\n                    ...response,\n                    messages: response.messages.map((message) => ({\n                        nodeId: message.nodeId,\n                        messageId: message.messageId,\n                        text: message.text,\n                        choices: message.choices ?? [],\n                    })),\n                },\n            };\n            setState({\n                responses: [...state.responses, newResponse],\n            }, newResponse);\n            if (response.metadata.hasPendingDataRequest) {\n                appendStructuredUserResponse({ poll: true });\n                setTimeout(() => {\n                    void sendToBot({\n                        request: {\n                            structured: {\n                                poll: true,\n                            },\n                        },\n                    });\n                }, 1500);\n            }\n        }\n        else {\n            Console.warn(\"Invalid message structure, expected object with field 'messages'.\");\n            failureHandler();\n        }\n    };\n    let botRequestOverride;\n    let socketMessageQueue = [];\n    let socketMessageQueueCheckInterval = null;\n    const sendToBot = async (body) => {\n        if (botRequestOverride != null) {\n            botRequestOverride(body, (payload) => {\n                const newResponse = {\n                    type: \"bot\",\n                    receivedAt: new Date().getTime(),\n                    payload,\n                };\n                setState({\n                    responses: [...state.responses, newResponse],\n                }, newResponse);\n            });\n            return;\n        }\n        const bodyWithContext = {\n            userId: state.userId,\n            conversationId: state.conversationId,\n            ...body,\n            languageCode: config.languageCode,\n            channelType: config.experimental?.channelType,\n            environment: config.environment,\n        };\n        if (isUsingWebSockets()) {\n            if (socket?.readyState === 1) {\n                socket.send(JSON.stringify(bodyWithContext));\n            }\n            else {\n                socketMessageQueue = [...socketMessageQueue, bodyWithContext];\n            }\n        }\n        else {\n            await fetch(`${config.botUrl}${config.experimental?.completeBotUrl === true\n                ? \"\"\n                : `-${config.languageCode}`}`, {\n                method: \"POST\",\n                headers: {\n                    ...(config.headers ?? {}),\n                    Accept: \"application/json\",\n                    \"Content-Type\": \"application/json\",\n                    \"nlx-sdk-version\": packageJson.version,\n                },\n                body: JSON.stringify(bodyWithContext),\n            })\n                .then(async (res) => {\n                return await res.json();\n            })\n                .then(messageResponseHandler)\n                .catch((err) => {\n                Console.warn(err);\n                failureHandler();\n            });\n        }\n    };\n    const isUsingWebSockets = () => {\n        return config.botUrl.indexOf(\"wss://\") === 0;\n    };\n    let subscribers = [];\n    const setupWebsocket = () => {\n        const url = new URL(config.botUrl);\n        if (config.experimental?.completeBotUrl !== true) {\n            url.searchParams.set(\"languageCode\", config.languageCode);\n            url.searchParams.set(\"channelKey\", `${url.searchParams.get(\"channelKey\") ?? \"\"}-${config.languageCode}`);\n        }\n        url.searchParams.set(\"conversationId\", state.conversationId);\n        socket = new ReconnectingWebSocket(url.href);\n        socketMessageQueueCheckInterval = setInterval(() => {\n        }, 500);\n        socket.onmessage = function (e) {\n            if (typeof e?.data === \"string\") {\n                messageResponseHandler(safeJsonParse(e.data));\n            }\n        };\n    };\n    const teardownWebsocket = () => {\n        if (socketMessageQueueCheckInterval != null) {\n            clearInterval(socketMessageQueueCheckInterval);\n        }\n        if (socket != null) {\n            socket.onmessage = null;\n            socket.close();\n            socket = undefined;\n        }\n    };\n    if (isUsingWebSockets()) {\n        setupWebsocket();\n    }\n    const appendStructuredUserResponse = (structured, context) => {\n        const newResponse = {\n            type: \"user\",\n            receivedAt: new Date().getTime(),\n            payload: {\n                type: \"structured\",\n                ...structured,\n                context,\n            },\n        };\n        setState({\n            responses: [...state.responses, newResponse],\n        }, newResponse);\n    };\n    const sendIntent = (intentId, context) => {\n        appendStructuredUserResponse({ intentId }, context);\n        void sendToBot({\n            context,\n            request: {\n                structured: {\n                    intentId,\n                },\n            },\n        });\n    };\n    const sendText = (text, context) => {\n        const newResponse = {\n            type: \"user\",\n            receivedAt: new Date().getTime(),\n            payload: {\n                type: \"text\",\n                text,\n                context,\n            },\n        };\n        setState({\n            responses: [...state.responses, newResponse],\n        }, newResponse);\n        void sendToBot({\n            context,\n            request: {\n                unstructured: {\n                    text,\n                },\n            },\n        });\n    };\n    const unsubscribe = (subscriber) => {\n        subscribers = subscribers.filter((fn) => fn !== subscriber);\n    };\n    const subscribe = (subscriber) => {\n        subscribers = [...subscribers, subscriber];\n        subscriber(fromInternal(state));\n        return () => {\n            unsubscribe(subscriber);\n        };\n    };\n    return {\n        sendText,\n        sendStructured: (structured, context) => {\n            appendStructuredUserResponse(structured, context);\n            void sendToBot({\n                context,\n                request: {\n                    structured: {\n                        ...structured,\n                        slots: normalizeSlots(structured.slots ?? []),\n                    },\n                },\n            });\n        },\n        sendSlots: (slots, context) => {\n            appendStructuredUserResponse({ slots }, context);\n            void sendToBot({\n                context,\n                request: {\n                    structured: {\n                        slots: normalizeSlots(slots),\n                    },\n                },\n            });\n        },\n        sendIntent,\n        sendWelcomeIntent: (context) => {\n            sendIntent(welcomeIntent, context);\n        },\n        sendChoice: (choiceId, context, metadata) => {\n            let newResponses = [...state.responses];\n            const choiceResponse = {\n                type: \"user\",\n                receivedAt: new Date().getTime(),\n                payload: {\n                    type: \"choice\",\n                    choiceId,\n                },\n            };\n            const responseIndex = metadata?.responseIndex ?? -1;\n            const messageIndex = metadata?.messageIndex ?? -1;\n            if (responseIndex > -1 && messageIndex > -1) {\n                newResponses = adjust(responseIndex, (response) => response.type === \"bot\"\n                    ? {\n                        ...response,\n                        payload: {\n                            ...response.payload,\n                            messages: adjust(messageIndex, (message) => ({ ...message, selectedChoiceId: choiceId }), response.payload.messages),\n                        },\n                    }\n                    : response, newResponses);\n            }\n            newResponses = [...newResponses, choiceResponse];\n            setState({\n                responses: newResponses,\n            }, choiceResponse);\n            void sendToBot({\n                context,\n                request: {\n                    structured: {\n                        nodeId: metadata?.nodeId,\n                        intentId: metadata?.intentId,\n                        choiceId,\n                    },\n                },\n            });\n        },\n        currentConversationId: () => {\n            return state.conversationId;\n        },\n        subscribe,\n        unsubscribe,\n        unsubscribeAll: () => {\n            subscribers = [];\n        },\n        reset: (options) => {\n            setState({\n                conversationId: v4(),\n                responses: options?.clearResponses === true ? [] : state.responses,\n            });\n            if (isUsingWebSockets()) {\n                teardownWebsocket();\n                setupWebsocket();\n            }\n        },\n        destroy: () => {\n            subscribers = [];\n            if (isUsingWebSockets()) {\n                teardownWebsocket();\n            }\n        },\n        setBotRequestOverride: (val) => {\n            botRequestOverride = val;\n        },\n    };\n}\n/**\n * Get current expiration timestamp from the current list of reponses\n * @param responses - the current list of user and bot responses (first argument in the subscribe callback)\n * @returns an expiration timestamp in Unix Epoch (`new Date().getTime()`), or `null` if this is not known (typically occurs if the bot has not responded yet)\n */\nconst getCurrentExpirationTimestamp = (responses) => {\n    let expirationTimestamp = null;\n    responses.forEach((response) => {\n        if (response.type === \"bot\" &&\n            response.payload.expirationTimestamp != null) {\n            expirationTimestamp = response.payload.expirationTimestamp;\n        }\n    });\n    return expirationTimestamp;\n};\n/**\n * This package is intentionally designed with a subscription-based API as opposed to a promise-based one where each message corresponds to a single bot response, available asynchronously.\n *\n * If you need a promise-based wrapper, you can use the `promisify` helper available in the package:\n * @example\n * ```typescript\n * import { createConversation, promisify } from \"@nlxai/chat-core\";\n *\n * const convo = createConversation(config);\n *\n * const sendTextWrapped = promisify(convo.sendText, convo);\n *\n * sendTextWrapped(\"Hello\").then((response) => {\n *   console.log(response);\n * });\n * ```\n * @typeParam T - the type of the function's params, e.g. for `sendText` it's `text: string, context?: Context`\n * @param fn - the function to wrap (e.g. `convo.sendText`, `convo.sendChoice`, etc.)\n * @param convo - the `ConversationHandler` (from {@link createConversation})\n * @param timeout - the timeout in milliseconds\n * @returns A promise-wrapped version of the function. The function, when called, returns a promise that resolves to the Conversation's next response.\n */\nfunction promisify(fn, convo, timeout = 10000) {\n    return async (payload) => {\n        return await new Promise((resolve, reject) => {\n            const timeoutId = setTimeout(() => {\n                reject(new Error(\"The request timed out.\"));\n                convo.unsubscribe(subscription);\n            }, timeout);\n            const subscription = (_responses, newResponse) => {\n                if (newResponse?.type === \"bot\" || newResponse?.type === \"failure\") {\n                    clearTimeout(timeoutId);\n                    convo.unsubscribe(subscription);\n                    resolve(newResponse);\n                }\n            };\n            convo.subscribe(subscription);\n            fn(payload);\n        });\n    };\n}\n\nexport { createConversation, getCurrentExpirationTimestamp, promisify, shouldReinitialize };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}